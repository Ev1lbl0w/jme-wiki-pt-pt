<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>Comparação técnica entre jME2 e jME3</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/ev1lbl0w/jme-wiki-pt-pt/edit/master/src/docs/asciidoc/compare-jme2-jme3.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/ev1lbl0w/jme-wiki-pt-pt/new/master/src/docs/asciidoc/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Comparação técnica entre jME2 e jME3</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#shaders">Shaders?</a></li><li><a href="#gestão-de-recursos">Gestão de recursos?</a></li><li><a href="#gestão-do-input">Gestão do input?</a></li><li><a href="#gestão-de-objetos-gl">Gestão de objetos GL?</a></li><li><a href="#colisão-picking">Colisão/Picking?</a></li><li><a href="#gestão-de-livrarias-nativas">Gestão de livrarias nativas?</a></li><li><a href="#efeitos-em-post-processing-em">Efeitos? (<em>Post processing</em>)</a></li><li><a href="#sombras">Sombras?</a></li><li><a href="#gestão-de-geometrys">Gestão de Geometrys?</a></li><li><a href="#updates-no-em-scene-graph-em">Updates no <em>scene graph</em>?</a></li><li><a href="#renderstate-material">RenderState/Material</a></li><li><a href="#suporte-para-em-fixed-function-em-gpus-antigas">Suporte para <em>fixed-function</em>/GPUs antigas?</a></li><li><a href="#capacidades-de-em-renderer-em">Capacidades de <em>renderer</em>?</a></li><li><a href="#math-object-pooling-vector-matrix-etc">Math object pooling (Vector, Matrix, etc)?</a></li><li><a href="#text">Text?</a></li><li><a href="#user-interface">User interface?</a></li><li><a href="#animation">Animation?</a></li><li><a href="#spatial-partitioning">Spatial partitioning?</a></li><li><a href="#model-formats">Model formats?</a></li><li><a href="#import-export">Import/Export?</a></li><li><a href="#physics">Physics?</a></li><li><a href="#canvas-support">Canvas support?</a></li><li><a href="#particles">Particles?</a></li><li><a href="#terrain">Terrain?</a></li></ul></div></div><div id="content"><div class="sect1"><h2 id="shaders">Shaders?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Os shaders estão integrados no núcleo e no sistema de materiais. O JME3 suporta livrarias de shader e permutações. Para "user-friendly" existem <em>post-processing filters</em>, <em>screen processors</em> e <a href="jme3/advanced/jme3_shadernodes.html"><em>shader nodes system</em></a> (não precisa de saber programar shaders para usá-los).</p><div class="ulist"><ul><li><p>jME2: Acesso total a suporte de shaders através dum RenderState, obriga o utilizador a saber fazer shaders. Não tem suporte para livrarias ou permutações.</p></li></ul></div></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-recursos">Gestão de recursos?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Integrados no núcleo. Todos os dados de ficheiros carregados são guardados em cache no AssetManager. Personalizável. Pode-se usar threads. Consegue ler ficheiros ZIP/JAR no disco local e num servidor HTTP.</p></li><li><p>jME2: Só as texturas são geridas pelo TextureManager. O ResourceLocatorTool é usado para localizar recursos.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-do-input">Gestão do input?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Desenhado para jogos. Abstrai teclado, rato e joystick numa única interface baseada em <em>bindings</em>. Existem interfaces <em>low level</em> para aceder à <abbr title="Graphical User Interface">GUI</abbr>.</p></li><li><p>jME2: Uma camada sobre o teclado, rato e joystick. A interface principal de input (InputManager) pode causar atrasos no código. Um sistema de <em>binding</em> está disponível em separado através do sistema de input com <em>bindings</em> do darkfrog.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-objetos-gl">Gestão de objetos GL?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Todos os objetos GL em desuso são apagados quando são <em>garbage collected</em> pelo Java.</p></li><li><p>jME2:  Todos os objetos dão <em>leak</em> a não ser que sejam limpos manualmente.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="colisão-picking">Colisão/Picking?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>BIH (Bounding interleaved hierarchy)</em> para colisão e picking de formas estáticas. Suporta colisões <em>Volume vs. Tri</em>.</p></li><li><p>jME2:  Árvore vermelha-preta sobre toda a <em>mesh data</em>, menos eficiente que o sistema BIH mas é mais rápido de criar para objetos animados. Suportas colisões <em>Tri vs. Tri</em> mas não suporta do tipo <em>Volume vs. Tri</em> que são os mais frequentes.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-livrarias-nativas">Gestão de livrarias nativas?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Copia as livrarias nativas e carrega-as no <em>runtime</em>.</p></li><li><p>jME2:  Não há, o utilizador tem de especificar a propriedade <em>java.library.path</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="efeitos-em-post-processing-em">Efeitos? (<em>Post processing</em>)</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>HDR/Tonemapping, SSAO, Bloom</em>(Brilho), <em>Radial Blur, Light Scattering</em>(Raios de Luz), <em>CartoonEdge</em>(Arestas Cartoon).</p></li><li><p>jME2:  <em>Bloom</em>(Brilho), Efeito de Desfoque Básico</p></li></ul></div></div></div>
<div class="sect1"><h2 id="sombras">Sombras?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Integradas no núcleo. Método de <em>shadow map</em> personalizável, suporta métodos básicos e de PSSM.</p></li><li><p>jME2:  ShadowedRenderPass para sombras <em>stencil</em>, há problemas se a câmara entrar no volume da sombra. DirectionalShadowMapPass para <em>shadow mapping</em> básico.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-geometrys">Gestão de Geometrys?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  O Geometry é um elemento do <em>scene graph</em> , contém um objeto <em>Mesh</em>(Forma). As <em>Meshes</em> contém <em>VertexBuffers</em> que especificam o # de componentes, tipp, <em>float/int buffer</em>. Isto permite que apenas uma forma seja partilhada com muitos elementos no <em>scene graph</em>. Suporta internamente functions como <em>Level of Detail</em>(Nível de Detalhe) e animação.</p></li><li><p>jME2:  O Geometry/TriMesh é um elemento do <em>scene graph</em> que contém <em>float buffers</em> e <em>int buffer_s, _VBO</em> só suposta modelos estáticos, atributos personalizados são especificados manualmente via <em>GLSLShaderDataLogic</em> e não funcionam se um <em>VBO</em> for usado.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="updates-no-em-scene-graph-em">Updates no <em>scene graph</em>?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>Flags</em> de atualizações previnem updates desnecessárias à cena.</p></li><li><p>jME2:  Todos os dados são atualizados no <em>updateGeometricState</em>. Cada <em>call</em> atualiza o <em>scene graph</em> todo, um mecanismo de bloquei é usado para reduzir updates desnecessárias mas requer intervenção do utilizador.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="renderstate-material">RenderState/Material</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Só em <em>leafs</em>. Um sistema de materiais <em>scriptable</em> é usado. Materiais contém técnicas que contém <em>shaders</em> &amp; <em>render states</em>. Um shader é personalizado com <em>defines</em> na instância do material (pelo utilizador). Esta é uma abordagem <em>data-driven</em> a materiais.</p></li><li><p>jME2:  Cada elementos do <em>scene graph</em> contém um array de <em>RenderStates</em>. São combinados e guardados em <em>leafs</em>. Não há soluções <em>data-driven</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="suporte-para-em-fixed-function-em-gpus-antigas">Suporte para <em>fixed-function</em>/GPUs antigas?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Existe suporte via <em>bindings FixedFunc</em> no <em>source</em> do shader.</p></li><li><p>jME2:  Suporte total.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="capacidades-de-em-renderer-em">Capacidades de <em>renderer</em>?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Empilhável através do <em>cap system</em>.</p></li><li><p>jME2:  Empilhável através do <em>Renderer</em> e dos vários <em>renderstates</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="math-object-pooling-vector-matrix-etc">Math object pooling (Vector, Matrix, etc)?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  ThreadLocal-based system, defined as instance variables accessible by any class. Assertion-based “locking is used to prevent data corruption.</p></li><li><p>jME2:  static declarations (kills multithreading in these classes) or no pooling at all.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="text">Text?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  AngelCode bitmap text</p></li><li><p>jME2:  Fixed-length font, 3D text, AngelCode bitmap text</p></li></ul></div></div></div>
<div class="sect1"><h2 id="user-interface">User interface?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Simple text and ortho built-in, NiftyGui integration can be used for more advanced user interface.</p></li><li><p>jME2:  Only simple text and ortho. jME-desktop (not working well under MacOS X), external libs available (FengGUI, GBUI, NiftyGui).</p></li></ul></div></div></div>
<div class="sect1"><h2 id="animation">Animation?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  OgreXML-based animation system with many features. Software skinning and hardware skinning are supported.</p></li><li><p>jME2:  Too many systems, creating a big mess. jME-xml and collada use one system, md2/md3 use another, milkshape models use another, ogrexml uses another and md5 uses another.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="spatial-partitioning">Spatial partitioning?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  None.</p></li><li><p>jME2:  None.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="model-formats">Model formats?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Ogre3D Mesh.XML and OBJ.</p></li><li><p>jME2:  Static/VertexAnim: ase, obj, 3ds, md2, md3, ms3d, x3d. Skeleton: (broken) collada, ogre3d, jme-xml (md5 as a seperate lib)</p></li></ul></div></div></div>
<div class="sect1"><h2 id="import-export">Import/Export?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Same as jME2. Don&#8217;t fix what&#8217;s not broken.</p></li><li><p>jME2:  Input/Output capsules and Savable. Binary and XML.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="physics">Physics?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Full JBullet integration.</p></li><li><p>jME2:  External libs available: jME-physics, jbullet-jme, SimplePhysics.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="canvas-support">Canvas support?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Yes.</p></li><li><p>jME2:  Yes, although the <abbr title="Application Programming Interface">API</abbr> could have been a little less convoluted.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="particles">Particles?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Yes.</p></li><li><p>jME2:  Yes but <abbr title="Application Programming Interface">API</abbr> could be a little less convoluted.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="terrain">Terrain?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Image based heightmap, supports dynamic terrain loading, geomipmapping (LOD), and texture splatting. Can import Ogre3D dotScene files for non-heightmap terrain.</p></li><li><p>jME2:  Image based or randomly generated heightmap. Quadtree support.</p></li></ul></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2018-01-24 21:50:12 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>