<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>Comparação técnica entre jME2 e jME3</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/ev1lbl0w/jme-wiki-pt-pt/edit/master/src/docs/asciidoc/compare-jme2-jme3.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/ev1lbl0w/jme-wiki-pt-pt/new/master/src/docs/asciidoc/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Comparação técnica entre jME2 e jME3</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#shaders">Shaders?</a></li><li><a href="#gestão-de-recursos">Gestão de recursos?</a></li><li><a href="#gestão-do-input">Gestão do input?</a></li><li><a href="#gestão-de-objetos-gl">Gestão de objetos GL?</a></li><li><a href="#colisão-picking">Colisão/Picking?</a></li><li><a href="#gestão-de-livrarias-nativas">Gestão de livrarias nativas?</a></li><li><a href="#efeitos-em-post-processing-em">Efeitos? (<em>Post processing</em>)</a></li><li><a href="#sombras">Sombras?</a></li><li><a href="#gestão-de-geometrys">Gestão de Geometrys?</a></li><li><a href="#updates-no-em-scene-graph-em">Updates no <em>scene graph</em>?</a></li><li><a href="#renderstate-material">RenderState/Material</a></li><li><a href="#suporte-para-em-fixed-function-em-gpus-antigas">Suporte para <em>fixed-function</em>/GPUs antigas?</a></li><li><a href="#capacidades-de-em-renderer-em">Capacidades de <em>renderer</em>?</a></li><li><a href="#em-pooling-em-de-objetos-matemáticos-vetor-matrix-etc"><em>Pooling</em> de objetos matemáticos (Vetor, Matrix, etc)?</a></li><li><a href="#texto">Texto?</a></li><li><a href="#interface-de-utilizador">Interface de utilizador?</a></li><li><a href="#animação">Animação?</a></li><li><a href="#particionamento-de-spatials">Particionamento de Spatials?</a></li><li><a href="#formatos-de-modelos">Formatos de modelos?</a></li><li><a href="#importar-exportar">Importar/Exportar?</a></li><li><a href="#física">Física?</a></li><li><a href="#suporte-para-em-canvas-em">Suporte para <em>Canvas</em>?</a></li><li><a href="#partículas">Partículas?</a></li><li><a href="#terreno">Terreno?</a></li></ul></div></div><div id="content"><div class="sect1"><h2 id="shaders">Shaders?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Os shaders estão integrados no núcleo e no sistema de materiais. O JME3 suporta livrarias de shader e permutações. Para "user-friendly" existem <em>post-processing filters</em>, <em>screen processors</em> e <a href="jme3/advanced/jme3_shadernodes.html"><em>shader nodes system</em></a> (não precisa de saber programar shaders para usá-los).</p><div class="ulist"><ul><li><p>jME2: Acesso total a suporte de shaders através dum RenderState, obriga o utilizador a saber fazer shaders. Não tem suporte para livrarias ou permutações.</p></li></ul></div></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-recursos">Gestão de recursos?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Integrados no núcleo. Todos os dados de ficheiros carregados são guardados em cache no AssetManager. Personalizável. Pode-se usar threads. Consegue ler ficheiros ZIP/JAR no disco local e num servidor HTTP.</p></li><li><p>jME2: Só as texturas são geridas pelo TextureManager. O ResourceLocatorTool é usado para localizar recursos.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-do-input">Gestão do input?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3: Desenhado para jogos. Abstrai teclado, rato e joystick numa única interface baseada em <em>bindings</em>. Existem interfaces <em>low level</em> para aceder à <abbr title="Graphical User Interface">GUI</abbr>.</p></li><li><p>jME2: Uma camada sobre o teclado, rato e joystick. A interface principal de input (InputManager) pode causar atrasos no código. Um sistema de <em>binding</em> está disponível em separado através do sistema de input com <em>bindings</em> do darkfrog.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-objetos-gl">Gestão de objetos GL?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Todos os objetos GL em desuso são apagados quando são <em>garbage collected</em> pelo Java.</p></li><li><p>jME2:  Todos os objetos dão <em>leak</em> a não ser que sejam limpos manualmente.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="colisão-picking">Colisão/Picking?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>BIH (Bounding interleaved hierarchy)</em> para colisão e picking de formas estáticas. Suporta colisões <em>Volume vs. Tri</em>.</p></li><li><p>jME2:  Árvore vermelha-preta sobre toda a <em>mesh data</em>, menos eficiente que o sistema BIH mas é mais rápido de criar para objetos animados. Suportas colisões <em>Tri vs. Tri</em> mas não suporta do tipo <em>Volume vs. Tri</em> que são os mais frequentes.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-livrarias-nativas">Gestão de livrarias nativas?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Copia as livrarias nativas e carrega-as no <em>runtime</em>.</p></li><li><p>jME2:  Não há, o utilizador tem de especificar a propriedade <em>java.library.path</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="efeitos-em-post-processing-em">Efeitos? (<em>Post processing</em>)</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>HDR/Tonemapping, SSAO, Bloom</em>(Brilho), <em>Radial Blur, Light Scattering</em>(Raios de Luz), <em>CartoonEdge</em>(Arestas Cartoon).</p></li><li><p>jME2:  <em>Bloom</em>(Brilho), Efeito de Desfoque Básico</p></li></ul></div></div></div>
<div class="sect1"><h2 id="sombras">Sombras?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Integradas no núcleo. Método de <em>shadow map</em> personalizável, suporta métodos básicos e de PSSM.</p></li><li><p>jME2:  ShadowedRenderPass para sombras <em>stencil</em>, há problemas se a câmara entrar no volume da sombra. DirectionalShadowMapPass para <em>shadow mapping</em> básico.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="gestão-de-geometrys">Gestão de Geometrys?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  O Geometry é um elemento do <em>scene graph</em> , contém um objeto <em>Mesh</em>(Forma). As <em>Meshes</em> contém <em>VertexBuffers</em> que especificam o # de componentes, tipp, <em>float/int buffer</em>. Isto permite que apenas uma forma seja partilhada com muitos elementos no <em>scene graph</em>. Suporta internamente functions como <em>Level of Detail</em>(Nível de Detalhe) e animação.</p></li><li><p>jME2:  O Geometry/TriMesh é um elemento do <em>scene graph</em> que contém <em>float buffers</em> e <em>int buffer_s, _VBO</em> só suposta modelos estáticos, atributos personalizados são especificados manualmente via <em>GLSLShaderDataLogic</em> e não funcionam se um <em>VBO</em> for usado.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="updates-no-em-scene-graph-em">Updates no <em>scene graph</em>?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  <em>Flags</em> de atualizações previnem updates desnecessárias à cena.</p></li><li><p>jME2:  Todos os dados são atualizados no <em>updateGeometricState</em>. Cada <em>call</em> atualiza o <em>scene graph</em> todo, um mecanismo de bloquei é usado para reduzir updates desnecessárias mas requer intervenção do utilizador.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="renderstate-material">RenderState/Material</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Só em <em>leafs</em>. Um sistema de materiais <em>scriptable</em> é usado. Materiais contém técnicas que contém <em>shaders</em> &amp; <em>render states</em>. Um shader é personalizado com <em>defines</em> na instância do material (pelo utilizador). Esta é uma abordagem <em>data-driven</em> a materiais.</p></li><li><p>jME2:  Cada elementos do <em>scene graph</em> contém um array de <em>RenderStates</em>. São combinados e guardados em <em>leafs</em>. Não há soluções <em>data-driven</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="suporte-para-em-fixed-function-em-gpus-antigas">Suporte para <em>fixed-function</em>/GPUs antigas?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Existe suporte via <em>bindings FixedFunc</em> no <em>source</em> do shader.</p></li><li><p>jME2:  Suporte total.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="capacidades-de-em-renderer-em">Capacidades de <em>renderer</em>?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Empilhável através do <em>cap system</em>.</p></li><li><p>jME2:  Empilhável através do <em>Renderer</em> e dos vários <em>renderstates</em>.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="em-pooling-em-de-objetos-matemáticos-vetor-matrix-etc"><em>Pooling</em> de objetos matemáticos (Vetor, Matrix, etc)?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Sistema baseado em <em>ThreadLocal</em>, definico como variáveis de instância e disponíveis a qualquer classe. Bloqueio basiado em <em>asserts</em> previne corrupção de dados.</p></li><li><p>jME2:  Declarações estáticas (destrói <em>multithreading</em> nestas classes) ou não há <em>pooling</em> sequer.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="texto">Texto?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Texto bitmap AngelCode</p></li><li><p>jME2:  Fontes de tamanho fixo, texto 3D, texto bitmap AngelCode</p></li></ul></div></div></div>
<div class="sect1"><h2 id="interface-de-utilizador">Interface de utilizador?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Texto simples e <em>ortho</em> integrados, integração com o NiftyGui pode ser usado para interfaces mais avançadas.</p></li><li><p>jME2:  Apenas texto simple e <em>ortho</em>. jME-desktop (não funciona bem no MacOS X), estão disponíveis livrarias externas (FengGUI, GBUI, NiftyGui).</p></li></ul></div></div></div>
<div class="sect1"><h2 id="animação">Animação?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Sistema de animação baseado no OgreXML com muitas funcionalidades. <em>Software skinning</em> e <em>hardware skinning</em> são suportados.</p></li><li><p>jME2:  Há demasiados sistemas, que criam uma confusão. O jME-xml e collada usam um sistema, md2/md3 usam outro, modelos milkshape usam outro, ogrexml usa outro e md5 usa outro.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="particionamento-de-spatials">Particionamento de Spatials?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Nenhum.</p></li><li><p>jME2:  Nenhum.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="formatos-de-modelos">Formatos de modelos?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Ogre3D Mesh.XML e OBJ.</p></li><li><p>jME2:  Static/VertexAnim: ase, obj, 3ds, md2, md3, ms3d, x3d. Skeleton: (não funciona) collada, ogre3d, jme-xml (md5 com livraria externa)</p></li></ul></div></div></div>
<div class="sect1"><h2 id="importar-exportar">Importar/Exportar?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  O mesmo que o jME2. Não reparem o que não está estragado.</p></li><li><p>jME2:  Cápsulas Input/Output e Savable. Binário e XML.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="física">Física?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Integração completa do JBullet.</p></li><li><p>jME2:  Estão disponíveis livrarias externas: jME-physics, jbullet-jme, SimplePhysics.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="suporte-para-em-canvas-em">Suporte para <em>Canvas</em>?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Sim.</p></li><li><p>jME2:  Sim, embora a <abbr title="Application Programming Interface">API</abbr> pudesse estar menos confusa.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="partículas">Partículas?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Sim.</p></li><li><p>jME2:  Sim, mas a <abbr title="Application Programming Interface">API</abbr> podia estar menos confusa.</p></li></ul></div></div></div>
<div class="sect1"><h2 id="terreno">Terreno?</h2><div class="sectionbody"><div class="ulist"><ul><li><p>jME3:  Baseado em imagens <em>heightmap</em>, suporta carregamento dinâmico de terreno, geomipmapping (LOD), e aplicação de texturas (<em>texture splatting</em>). Podem-se importar ficheiros <em>dotScene</em> do Ogre3D para terreno não-<em>heightmap</em>.</p></li><li><p>jME2:  Baseado em imagens ou em <em>heightmaps</em> criados aleatoriamente. Suporte a Quadtree.</p></li></ul></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2018-05-04 17:36:31 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>