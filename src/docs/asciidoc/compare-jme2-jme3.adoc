= Comparação técnica entre jME2 e jME3
:author: 
:revnumber: 
:revdate: 2016/03/17 20:48
ifdef::env-github,env-browser[:outfilesuffix: .adoc]



== Shaders?

*  jME3: Os shaders estão integrados no núcleo e no sistema de materiais. O JME3 suporta livrarias de shader e permutações. Para "user-friendly" existem _post-processing filters_, _screen processors_ e <<jme3/advanced/jme3_shadernodes#, _shader nodes system_>> (não precisa de saber programar shaders para usá-los).
**  jME2: Acesso total a suporte de shaders através dum RenderState, obriga o utilizador a saber fazer shaders. Não tem suporte para livrarias ou permutações.


== Gestão de recursos?

*  jME3: Integrados no núcleo. Todos os dados de ficheiros carregados são guardados em cache no AssetManager. Personalizável. Pode-se usar threads. Consegue ler ficheiros ZIP/JAR no disco local e num servidor HTTP.
*  jME2: Só as texturas são geridas pelo TextureManager. O ResourceLocatorTool é usado para localizar recursos.


== Gestão do input?

*  jME3: Desenhado para jogos. Abstrai teclado, rato e joystick numa única interface baseada em _bindings_. Existem interfaces _low level_ para aceder à +++<abbr title="Graphical User Interface">GUI</abbr>+++.
*  jME2: Uma camada sobre o teclado, rato e joystick. A interface principal de input (InputManager) pode causar atrasos no código. Um sistema de _binding_ está disponível em separado através do sistema de input com _bindings_ do darkfrog.


== Gestão de objetos GL?

*  jME3:  Todos os objetos GL em desuso são apagados quando são _garbage collected_ pelo Java.
*  jME2:  Todos os objetos dão _leak_ a não ser que sejam limpos manualmente.


== Colisão/Picking?

*  jME3:  _BIH (Bounding interleaved hierarchy)_ para colisão e picking de formas estáticas. Suporta colisões _Volume vs. Tri_.
*  jME2:  Árvore vermelha-preta sobre toda a _mesh data_, menos eficiente que o sistema BIH mas é mais rápido de criar para objetos animados. Suportas colisões _Tri vs. Tri_ mas não suporta do tipo _Volume vs. Tri_ que são os mais frequentes.


== Gestão de livrarias nativas?

*  jME3:  Copia as livrarias nativas e carrega-as no _runtime_.
*  jME2:  Não há, o utilizador tem de especificar a propriedade _java.library.path_.


== Efeitos? (_Post processing_)

*  jME3:  _HDR/Tonemapping, SSAO, Bloom_(Brilho), _Radial Blur, Light Scattering_(Raios de Luz), _CartoonEdge_(Arestas Cartoon).
*  jME2:  _Bloom_(Brilho), Efeito de Desfoque Básico


== Sombras?

*  jME3:  Integradas no núcleo. Método de _shadow map_ personalizável, suporta métodos básicos e de PSSM.
*  jME2:  ShadowedRenderPass para sombras _stencil_, há problemas se a câmara entrar no volume da sombra. DirectionalShadowMapPass para _shadow mapping_ básico.


== Gestão de Geometrys?

*  jME3:  O Geometry é um elemento do _scene graph_ , contém um objeto _Mesh_(Forma). As _Meshes_ contém _VertexBuffers_ que especificam o # de componentes, tipp, _float/int buffer_. Isto permite que apenas uma forma seja partilhada com muitos elementos no _scene graph_. Suporta internamente functions como _Level of Detail_(Nível de Detalhe) e animação.
*  jME2:  O Geometry/TriMesh é um elemento do _scene graph_ que contém _float buffers_ e _int buffer_s, _VBO_ só suposta modelos estáticos, atributos personalizados são especificados manualmente via _GLSLShaderDataLogic_ e não funcionam se um _VBO_ for usado.


== Updates no _scene graph_?

*  jME3:  _Flags_ de atualizações previnem updates desnecessárias à cena.
*  jME2:  Todos os dados são atualizados no _updateGeometricState_. Cada _call_ atualiza o _scene graph_ todo, um mecanismo de bloquei é usado para reduzir updates desnecessárias mas requer intervenção do utilizador.


== RenderState/Material

*  jME3:  Só em _leafs_. Um sistema de materiais _scriptable_ é usado. Materiais contém técnicas que contém _shaders_ &amp; _render states_. Um shader é personalizado com _defines_ na instância do material (pelo utilizador). Esta é uma abordagem _data-driven_ a materiais.
*  jME2:  Cada elementos do _scene graph_ contém um array de _RenderStates_. São combinados e guardados em _leafs_. Não há soluções _data-driven_.


== Suporte para _fixed-function_/GPUs antigas?

*  jME3:  Existe suporte via _bindings FixedFunc_ no _source_ do shader.
*  jME2:  Suporte total.


== Capacidades de _renderer_?

*  jME3:  Empilhável através do _cap system_.
*  jME2:  Empilhável através do _Renderer_ e dos vários _renderstates_.


== Math object pooling (Vector, Matrix, etc)?

*  jME3:  ThreadLocal-based system, defined as instance variables accessible by any class. Assertion-based “locking is used to prevent data corruption.
*  jME2:  static declarations (kills multithreading in these classes) or no pooling at all.


== Text?

*  jME3:  AngelCode bitmap text
*  jME2:  Fixed-length font, 3D text, AngelCode bitmap text


== User interface?

*  jME3:  Simple text and ortho built-in, NiftyGui integration can be used for more advanced user interface.
*  jME2:  Only simple text and ortho. jME-desktop (not working well under MacOS X), external libs available (FengGUI, GBUI, NiftyGui).


== Animation?

*  jME3:  OgreXML-based animation system with many features. Software skinning and hardware skinning are supported.
*  jME2:  Too many systems, creating a big mess. jME-xml and collada use one system, md2/md3 use another, milkshape models use another, ogrexml uses another and md5 uses another.


== Spatial partitioning?

*  jME3:  None.
*  jME2:  None.


== Model formats?

*  jME3:  Ogre3D Mesh.XML and OBJ.
*  jME2:  Static/VertexAnim: ase, obj, 3ds, md2, md3, ms3d, x3d. Skeleton: (broken) collada, ogre3d, jme-xml (md5 as a seperate lib)


== Import/Export?

*  jME3:  Same as jME2. Don't fix what's not broken.
*  jME2:  Input/Output capsules and Savable. Binary and XML.


== Physics?

*  jME3:  Full JBullet integration.
*  jME2:  External libs available: jME-physics, jbullet-jme, SimplePhysics.


== Canvas support?

*  jME3:  Yes.
*  jME2:  Yes, although the +++<abbr title="Application Programming Interface">API</abbr>+++ could have been a little less convoluted.


== Particles?

*  jME3:  Yes.
*  jME2:  Yes but +++<abbr title="Application Programming Interface">API</abbr>+++ could be a little less convoluted.


== Terrain?

*  jME3:  Image based heightmap, supports dynamic terrain loading, geomipmapping (LOD), and texture splatting. Can import Ogre3D dotScene files for non-heightmap terrain.
*  jME2:  Image based or randomly generated heightmap. Quadtree support.
